**前言**

https://mp.weixin.qq.com/s/HDA9LPsULXsw6iYzrsGGIA

题目难度适中。第一题是一个经典的板子题了，练过的都能拿下。第二题需要一些思维上的转变，难度不算很大。最后一题图论，难度也适中。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一活动介绍，有兴趣参加活动也可以了解一下！**

## **第一题**

小红定义一个字符串权值为:相邻字母相等的对儿数。例如，`aaabbc` 的权值是`3`。现在小红拿到了一个字符串，她想取一个连续子串满足权值恰好等于`k`。小红希望你帮她求出子串长度的最小值。你能帮帮她吗?

#### **输入描述**

第一行输入两个正整数`n`,`k`，代表小红拿到的字符串长度、取的连续子串的权值。

第二行输入一个长度为`n`的、仅由小写字母组成的字符串。$(1≤k<n≤300000)$< p=""></n≤300000)$<>

#### **输出描述**

如果不存在一个合法的子串满足条件，请输出`-1`，否则输出一个正整数，代表连续了串的最小长度。

#### **示例：**

**输入：**

```
6 2
aaabbc
```

**输出：**

```
3
```

**思路与代码**

采用双指针算法，处理处当前窗口内的字符串权值为`k`，求出一个最小的窗口大小。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;


int main()
{
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    int res = 0, ans = n + 1;
    for(int i = 0, j = i + 1; i < n; i ++)
    {
        if(i && s[i] == s[i - 1]) res --;
        while(j < n && res < k)
        {
            if(s[j] == s[j - 1]) res ++;
            j ++;
        }
        if(res == k)
        {
            ans = min(ans, j - i);
        }
    }
    if(ans == n + 1) ans = -1;
    cout << ans;
    return 0;
}
```

## **第二题**

小红拿到了一个长度为`n`的数组`a`，她希望你构造两个长度为`n`的排列`p`和`q`，满足以下条件:

1. 
2. 

你能帮帮她吗?

所谓排列，指一个长度为`n`的数组，其中`1`到`n`每个元素恰好出现`1`次。

#### **输入描述**

第一行输入一个正整数`n`，代表小红拿到的数组大小。第二行输入`n`个整数，代表小红拿到的数组。



#### **输出描述**

如果无解，请输出`-1`。 否则第一行输出`n`个正整数，第二行输出`n`个正整数，代表小红构造的两个排列。有多解时输出任意即可。

#### **示例：**

**输入：**

```
3
2 2 0
```

**输出：**

```
1 3 2
3 1 2
```

**思路与代码**

对于,这样的和 是确定的，所以可以提前把 的值处理出来，保存到c数组中，如果输入的a数组和c数组排序后不相同，则无解。可以用map存储每个对应的和。

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
const int N = 1e5 +7;
int a[N], b[N], c[N];
map<int, vector<pair<int, int>>> mp;
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i ++)
    {
        cin >> a[i];
        b[i] = a[i];
    }
    for(int i = 0; i < n; i ++)
    {
        c[i] = abs(i - (n - 1 - i));
        mp[c[i]].push_back({i, n - 1 - i});
    }
    sort(c, c + n);
    sort(b, b + n);
    for(int i = 0; i < n; i++) 
    {
        if(b[i] != c[i]) 
        {
            cout << "-1";
            return 0;
        }
    }
    vector<int> xx(n), yy(n);
    for(int i = 0; i < n; i ++)
    {
        int t = a[i];
        auto x = mp[t].back();
        mp[t].pop_back();
        xx[i] = x.first, yy[i] = x.second;
    }
    for(int i = 0; i < n; i ++) cout << xx[i] + 1 << " ";
    cout << endl;
    for(int i = 0; i < n; i ++) cout << yy[i] + 1 << " ";
    return 0;
}
```

## **第三题**

小红拿到了一个森林(即若干棵树组成的无向图)。她可以进行若干次以下操作:

1. 新增一个节点，连接在任意节点上。
2. 选择一个叶子，删除对应的节点和边。

小红希望最终森林的每个连通块的大小都相同，请你帮小红求出最少的操作次数。

#### **输入描述**

第一行输入两个正整数`n`，`m`，代表森林的点数和边数。 接下来的`m`行，每行输入两个正整数`u`,`v`，代表`u`号节点和`u`号节点有一条边连接。

$1≤m<n≤10^5$< p=""></n≤10^5$<>



保证给定的无向图是一个森林。

#### **输出描述**

一个整数，代表小红最小的操作次数。

#### **示例：**

**输入：**

```
4 2
1 2
1 3
```

**输出：**

```
2
```

说明： 操作2次，分别将一个节点连接在4号上面，这样两个连通块的大小均为3。

**思路与代码**

先用并查集处理出每个连通块的大小，这样就把问题转化成了使数组值都一样的代价了。把数组先排序，用前缀和算出前i个数组的和，这样就可以（cnt为连通快个数）复杂度算出变成变成的代价了，遍历所有的连通快就能算出一个最小的代价。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 1e5 +7;
typedef long long LL;

int n, m, p[N], num[N], c[N], sum[N];
int find(int x)  
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) p[i] = i, num[i] = 1;
    for(int i = 0; i < m; i ++)
    {
        int a, b;
        cin >> a >> b;
        int px = find(a), py = find(b);
        if(px != py)
        {
            p[px] = py;
            num[py] += num[px];
        }
    }
    int cnt = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(p[i] == i) c[cnt ++] =  num[i];
    }
    sort(c, c + cnt);
    for(int i = 0; i < cnt; i ++)
    {
        sum[i] += c[i];
        if(i > 0) sum[i] += sum[ i - 1];
    }
    int res = n;
    for(int i = 0; i < cnt; i ++)
    {
        res = min((LL)res, (LL)(i + 1) * c[i] - sum[i] + sum[cnt - 1] - sum[i] - (LL)(cnt - i - 1) * c[i]);
    }
    cout << res;
    return 0;
}
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab） 	