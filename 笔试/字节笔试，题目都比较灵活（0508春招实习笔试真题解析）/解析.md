**前言**

https://mp.weixin.qq.com/s/_-qWQ1jRNDUg-nXqvj6Ycw

本次笔试难度中等偏上，技巧性比较强。第一题分析好性质不会很难。第二题有一定难度，构造题。第三题还是比较偏板子，会板子的难度就不大。第四题dp，难度不低，需要灵活处理和分析。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一进阶提高的活动介绍，有兴趣的同学也可以了解一下！**

## 第一题：

有n个自爆怪，每只怪物血量为a~i~，并且怪物死亡时(血量小于等于0)会发生自爆，对其他怪物造成等同于其初始血量的伤害。小杰每次攻击可以对任意一只怪物造成1点伤害。她想知道，最少攻击多少次可以击杀全部怪物?

**输入描述**

第一行输入一个正整数n，代表怪物的数量

第二行输入n个正整数a~i~，代表每只怪物的血量。1<n<10^5^  1<a~i~< 10^9^

**输出描述**

一个正整数，代表小杰的最小攻击次数 示例 1

**输入**

> 3
>
> 1 2 3

**输出**

> 2

**说明**

> 对第1只怪物、第2只怪物名攻击次即可。攻击第1只怪物时，第1只怪物死亡时白爆，对第 2、3 只怪物备造成1点伤害。此时第2只怪物血量只剩1点，再攻击一次即可。然后第2只怪物自爆，对第3只怪物造成2点伤害，第3 只怪物也死亡。

**思路与代码**

优先攻击血量小的怪物，使得它们死亡时能对其他血量较高的怪物造成伤害。如果当前累计造成的伤害点小于当前怪物的血量，那么需要额外进行（ 血量-伤害点）次攻击，以确保这只怪物死亡。额外的攻击次数被累加到最终结果中。每次怪物死亡时（无论是通过攻击还是其他怪物的自爆），它都会对剩余的怪物造成等同于其血量的伤害。因此，更新累计造成的伤害 ，即将当前怪物的血量加上。

```
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        // 创建一个优先队列，自然排序实现最小堆
        PriorityQueue<Integer> q = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            int t = scanner.nextInt();
            q.offer(t); // 向优先队列中添加元素
        }
        int res = 0;
        int s = 0;
        while (!q.isEmpty()) {
            int x = q.poll(); // 从优先队列中取出并移除队首元素
            if (s < x) {
                res += x - s;
            }
            s += x;
        }
        System.out.println(res);
    }
}
```

## 第二题

小杰有一个长为n的排列p，但大白熊将其隐藏了起来。现在大白熊给了小杰一个长度为n-1的数组a，其中a~i~=p~i~ + p~i+1~ 小杰想用数组a还原出排列p来，你能帮帮她吗

**输入描述**

输入包含两行。第一行一个正整数n(1≤n≤ 2 x 10^3^)

表示排列p 的长度。

第二行n-1个正整数a~i~(1<a~i~<n+(n-1))，表示题中所述数组a的元素。

**输出描述**

输出包含一行n个数字，表示还原出来的排列p。如果有多解，请输出字典序最小的解，但如果无解，请输出 -1。

**示例 1**

**输入**

> 4 5 7 5

**输出**

> 1 4 3 2

**思路与代码**

要从给定的输入数组  中推导出 `p` 的可能值。但由于 `p` 是一个排列，尝试从 `1` 到 `n` 的所有可能的首元素开始，尝试构建整个排列 `p` 并验证它是否满足条件。要求字典序最小，所以从1开始，设置两个数组，一个为输入的数组，一个数组第一个为1，剩余元素由输入数组作差得到。以此类推，最后得到符合的排列。

```
public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 1; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        for (int i = 1; i < n; i++) {
            int[] t = new int[n];
            t[0] = 1;
            Set<Integer> map = new HashSet<>();
            map.add(t[0]);
            for (int j = 1; j < n; j++) {
                t[j] = a[j] - t[j - 1];
                if(t[j]>n||t[j]<=0) break;
                map.add(t[j]);
            }
            if (map.size() == n) {
                for (int num : t) {
                    System.out.print(num + " ");
                }
                System.out.println();
                return;
            }
        }
        System.out.println("-1");
    }
}
```

## 第三题：

小杰在一个矩阵的左上角，她准备跳到右下角。小杰必须按照象棋的"马"的规则移动，即如果当前的坐标是(x~0~,y~0~)，那么落点的坐标(x,y)必须满足|x-x~0~| +|y - y~0~| = 3且x ≠o,y ≠y~0~。小杰每跳一步就会收集落点的数字加入到总和里。她想知道最终最小的总和是多少?

**输入描述**

第一行输入两个正整效n,n、代表矩阵的行数和列数 接下来的几行，每行输入m个正整数a~ij~，代表矩阵的元素。1≤n,m≤800

1≤a~ij~≤ 10~9~

**输出描述**

如果无法到达，请输出-1。否则输出一个正整数，代表最终的最小点和

**示例 1**

**输入**

> 4 4
>
> 1 2 3 4
>
> 5 6 7 8
>
> 9 10 11 12
>
> 1 2  3  4

**输出**

> 12

**说明**

> 1+7+4-12

**思路与代码：**

使用最短路径算法——迪杰斯特拉算法的思想，找到从二维网格的左上角(0, 0)到右下角(n-1, m-1)的最短路径权重之和。需要使用`visited`的二维整型数组，用于标记某个单元格是否已被处理,防止重复处理。使用优先队列对其进行优化，确保每次都处理当前距离最短的节点。从队列中取出路径权重最小的点，更新其邻接点的最短路径权重，如果有更新，则将邻接点加入队列中。

```
public class Main {
    static int[] dx = {-2, -2, -1, -1, 1, 1, 2, 2};
    static int[] dy = {-1, 1, -2, 2, -2, 2, -1, 1};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                a[i][j] = scanner.nextLong();
            }
        }
        long[][] d = new long[n][m];
        int[][] visited = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(d[i], Long.MAX_VALUE);
        }
        d[0][0] = a[0][0];
        PriorityQueue<long[]> q = new PriorityQueue<>(Comparator.comparingLong(arr->arr[0]));
        q.add(new long[]{d[0][0], 0, 0});
        while (!q.isEmpty()) {
            long[] top = q.poll();
            long dis = top[0];
            int x = (int) top[1];
            int y = (int) top[2];
            visited[x][y] = 1;
            for (int i = 0; i < 8; i++) {
                int tx = x + dx[i];
                int ty = y + dy[i];
                if (tx >= 0 && tx < n && ty >= 0 && ty < m && visited[x][ty] == 0 && d[tx][ty] > dis + a[tx][ty]) {
                    d[tx][ty] = dis + a[tx][ty];
                    q.add(new long[]{d[tx][ty], tx, ty});
                }
            }
        }
        Long max = Long.MAX_VALUE;
        if (d[n - 1][m - 1] == max) {
            System.out.println("-1");
        } else {
            System.out.println(d[n - 1][m - 1]);
        }
    }
}
```

## 第四题：

小杰 定义一个字符串是"好串"，当且仅当该字符串包含"ab"子序列。

现在小杰 拿到了一个仅由'a'和"b'组成的字符串。他想知道，该字符串有多少子序列是好串?

定义字符串的子序列为:字符串从左到右取若干字符(在原串中可以不连续)组成的新串。例如，"arcaea"的子序列有"ace"等

**输入描述**

一个仅包含'a'和'b'的字符串，长度不超过10^5^

**输出描述**

好子序列的数量。由于答案可能过大，请对10^9^+ 7取模。

**示例 1**

**输入**

> abab

**输出**

> 8

**说明**

> 长度为4的子序列"abab"是好串。长度为3的子序列共有4个，都是好串，长度为2的子序列仅"ab"是好串，共有3个"ab"子序列。答案是1+4+3=8。

**思路与代码**

使用dp的想法，进行转态转移。分别对有'a'的子序列的数量，既没有a 也没有ab的子序列的数量，有'ab'的子序列的数量分别进行计数，随后遍历字符串的每个值。

1. 原先就是好的子序列，那么每增加一个字符，之前的所有好子序列都可以在不增加新字符或增加新字符的情况下翻倍。
2. 要是当前字符是a,那么新的`a`字符可以独立形成子序列，也可以附加到所有有`a`或`b`的子序列中。
3. 如果当前字符是'b'，则`b`的值翻倍（因为每个`b`都可以独立形成子序列或附加到有`b`的子序列中）。将`a`的当前值加到`ab`上，因为每个`b`都可以和之前所有的有`a`的子序列形成一个新的好子序列。

```
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int n = s.length();
        long a = 0, b = 1;
        long ab = 0;
        long mod = 1000000007;
        for (int i = 0; i < n; i++) {
            ab += ab;
            ab%=mod;
            if (s.charAt(i) == 'a') {
                a += a + b;
                a %= mod;
            } else {
                b += b;
                b %= mod;
                ab += a;
                ab %= mod;
            }
        }
        System.out.println(ab);
    }
}
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab）