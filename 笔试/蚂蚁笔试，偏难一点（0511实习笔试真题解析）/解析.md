**前言**

https://mp.weixin.qq.com/s/x9y0a4jnB8aQBqP_ikOAqg

本次笔试难度中等，偏难。第一题还算是比较简单的，考虑全面一点即可AC。第二题几何题，不难，但是代码容易出错。第三题比较难，跟数据结构没关系，就是纯数学题。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一进阶提高的活动介绍，有兴趣的同学也可以了解一下！**

## 小红的元素取反

小红定义一个数组的权值为：正数的元素数量减去负数的元素数量。例如，[1,2,-3,-4,5]的权值是1，[-2,-5]的权值是-2。

现在小红拿到了一个数组，她准备选择恰好k个元素进行取反（同一个元素最多只能取反一次），之后使得数组的权值尽可能大。你能帮帮她吗？

**输入描述**

第一行输入两个正整数n,k，代表小红拿到的数组和选择的元素数量。第二行输入n个整数ai，用空格隔开。代表小红拿到的数组。1<=k<=n<=10^5 -10^9<=ai<=10^9

**输出描述**

一个整数，代表操作后数组权值的最大值。

**示例 1**

输入

```
5 3
-5 1 4 -2 3
```

输出

```
3
```

**说明**

选择第1、3、4个元素取反，数组变成[5,1,-4,2,3]，权值为3。

**思路与代码**

思维题。

总体的思路就是让正数尽可能变多

1. 如果负数的数量大于等于k，那么可以将k个负数转换成k；
2. 其次考虑0的数量，如果条件1不满足，那么考虑0的数量，如果负数的数量 + 0的数量 大于等于k，那么可以将所有的负数变为正数。
3. 否则，再把所有的负数变为正数，并且将所有的0也翻转一次后，剩余的次数是需要把**正数变为负数的。**

```
n,k = map(int,input().split())
nums = list(map(int,input().split()))

# 统计大于0的数的个数
cnt1 = sum([1 for i in nums if i > 0])
cnt2 = sum([1 for i in nums if i < 0])
zero = n - cnt1 - cnt2

if k <= cnt2 :
    print(cnt1 - cnt2 + 2*k)
else:
    if zero + cnt2 >= k:
        print(cnt1 + cnt2)
    else:
        print(cnt1 + cnt2 - 2*(k - zero - cnt2))
```

## 小红的等腰梯形

小红在平面上拿到了四个点，请你判断这四个点是否构成等腰梯形。定义等腰梯形为：四条边分为两对，有一对边平行且不相等，另一对边相等且不平行。

**输入描述**

第一行输入一个整数q，代表询问次数。接下来的q行，每行输入8个整数p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y，代表询问的四个点的坐标。

1<=q<=1000

-1000<=pix,piy<=1000

**输出描述**

输出q行。如果询问的答案是等腰梯形，则输出"Yes"。否则输出"No"。

**示例 1**

**输入**

```
3
0 0 2 4 5 0 3 4
0 0 1 4 2 0 3 4
0 1 2 1 3 2 3 4
```

**输出**

```
Yes
No
Yes
```

**说明**

第一组询问的如下图，满足等腰梯形的条件。第二组询问的为平行四边形，并不是等腰梯形。

第三组询问的也是等腰梯形。请注意平行的边不一定必须和坐标轴也平行。

![图片](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/640.webp)

**思路与代码**

几何题。

如何构成等腰梯形？满足以下2个条件：

1. 有且只存在两条边平行
2. 侧边相等

按照以上条件枚举4个点的所有可能即可。

```
q = int(input())

# 判断两条边是否平行
def jdg(p1, p2, p3, p4):
    return (p2[1] - p1[1]) * (p4[0] - p3[0]) == (p4[1] - p3[1]) * (p2[0] - p1[0])

# 计算两点之间的距离
def dis(p1,p2):
    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

for _ in range(q):
    p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y = map(int,input().split())
    p1 = (p1x,p1y)
    p2 = (p2x,p2y)
    p3 = (p3x,p3y)
    p4 = (p4x,p4y)
    if (jdg(p1,p2,p3,p4) and not jdg(p1,p3,p2,p4) and not jdg(p1,p4,p2,p3) and (dis(p1,p3)==dis(p2,p4) or dis(p1,p4)==dis(p2,p3))) or \
            (jdg(p1,p3,p2,p4) and not jdg(p1,p2,p3,p4) and not jdg(p1,p4,p2,p3) and (dis(p1,p2)==dis(p3,p4) or dis(p1,p4)==dis(p2,p3))) or \
            (jdg(p1,p4,p2,p3) and not jdg(p1,p2,p3,p4) and not jdg(p1,p3,p2,p4) and (dis(p1,p2)==dis(p4,p3) or dis(p1,p3)==dis(p2,p4))):
        print('Yes')
    else:
        print("No")
```

## 小红的数组权值和

小红定义一个数组的权值为，该数组的连续段数量。所谓连续段，即相邻的相同元素均在一个连续段内。例如，[1,1,2,3,3,3,3]的连续段数量为3。

现在小红想知道，长度为n的、元素范围为[1,m]的所有数组的权值之和是多少？

**输入描述**

两个正整数n,m，用空格隔开。

1<=n，m<=10^9

**输出描述**

长度为n的、元素范围为[1,m]的所有数组的权值之和。由于答案过大，请对10^9+7取模。

**示例 1**

**输入**

2 3

**输出**

15

**说明**

长度为2的、元素范围为[1,3]的数组共有9个，其中[1,1]、[2,2]、[3,3]的权值是1，其余权值是2。因此答案是6*2+3=15

**思路与代码**

数学题。

1. 所有可能的数组的组合的数量是  m^n，初始权值至少为1。
2. 对于第 i 个元素（i 从 2 到 n），如果它与前一个元素不同，它就会新增一个连续段。概率是 (m−1)/m，因此期望贡献是 (m−1)/m * m^n= (m-1)*m^(n-1)。对于 n−1 个位置，总的贡献是 (n-1) * (m-1)*m^(n-1)，因此，总的权值是二者相加

```
n,m = map(int,input().split())

MOD = 1000000007
m_n = pow(m, n, MOD)
if n == 1:
    print(m_n)
m_n_1 = pow(m, n - 1, MOD)
add = (n - 1) * (m - 1) % MOD * m_n_1 % MOD
print((m_n + add) % MOD)
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab） 