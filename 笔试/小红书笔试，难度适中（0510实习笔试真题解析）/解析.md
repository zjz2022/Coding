**前言**

https://mp.weixin.qq.com/s/gqaS7rVfeMK3UH8Nl2DcRQ

本次笔试难度适中，但是出现了很多原题。 第一题打卡题，没什么技巧。 第二题需要进行分析性质后，使用堆进行优化。 第三题二分答案，有一定的难度。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一进阶提高的活动介绍，有兴趣的同学也可以了解一下！**

## 第一题 小红的碾压墙

**题目描述：**

小红是游戏《H炉》的一个主播。她经常去小红书发布关于H炉的卡牌研究攻略。

H炉有一张牌叫做碾压墙，可以消灭敌方最左边和最右边的随从，另一张牌叫做致命射击，可以随机消灭一个敌方随从。

如果小红使用两张致命射击恰好消灭了敌方最左边和最右边的随从（恰好造成了一张碾压墙的效果），就会有人在评论区发布“碾压墙” 。注意：两张致命射击的结算有先后顺序，即两张致命射击不会消灭同一个敌方随从。

现在有 n 个敌方随从，小红想知道她使用两张致命射击后，恰好造成一张碾压墙的效果的概率是多少。你的答案请四舍五入保留10位小数。

**输入描述**

第一行输入一个整数 n(2 ≤ n ≤ 106) 。

**输出描述**

输出一个实数表示答案(请四舍五入保留10位小数)。

**样例输入**

```
2
```

**样例输出**

```
1.0000000000
```

**提示**

```
说明只有两个随从，必然造成碾压墙的效果。
 
示例 2
输入
3
输出
0.3333333333
```

**思路与代码**

简单数学。

第一次选取头或者尾的概率为2/n，第二次选取剩余的头尾部分是1/(n-1)，二者相乘即可。

```
n = int(input())
#保留10位小数
print('%.10f' % (2/n * 1/(n-1)))
```

## 第二题 小红的精选笔记

时间限制: 1000MS 内存限制: 262144KB

**题目描述:**

小红在小红书上面发布了n篇笔记，其中第i筒笔记的点赞数量为ai,评论数为bi,。现在小红准备选择k筒笔记作为“精选笔记合集”，合集的优秀程度为:所有笔记点赞数之和乘以评论数的最小值。 现在小红想知道，最终台集最大的优秀度是多少?

**输入描述**

第一行输入两个正整数n,k,代表笔记的数量,以及小红准备选择的合集大小。 第二行输入n个正整教ai,代表每简笔记的点赞数。第三行输入n个正整数bi,代表每篇笔记的评论数。

**输出描述**

—个正整数,代表最终最大的优秀度。

**样例输入**

```
4 2
1 2 3 4

3 4 2 1
```

**样例输出**

10

**提示**

选第二篇和第三篇即可。

**思路与代码**

比较简单：按照评论数排序，考虑每个评论数作为最小评论数，统计大于当前评论数的笔记中最大的k个点赞数之和，这一步可以用**优先队列**实现。

```
import heapq

n,k = map(int,input().split())
A = list(map(int,input().split()))
B = list(map(int,input().split()))

notes = [[A[i],B[i]] for i in range(n)]

notes.sort(key = lambda x:-x[1])

h = [] #堆，点赞数的topk问题
sum_ = 0
res = 0
for i in range(n):
    if len(h) < k:
        heapq.heappush(h,notes[i][0])
        sum_ += notes[i][0]
    else:
        if h[0] < notes[i][0]:
            sum_ -= heapq.heappop(h)
            heapq.heappush(h,notes[i][0])
            sum_ += notes[i][0]
    if len(h) >= k: res = max(res, sum_ * notes[i][1])
print(res)
```

## 第三题 小红的点赞

小红发布了n个笔记，每个笔记的点赞数为。小红观察到，每隔一段时间，某个笔记的点赞数就会加1。但是不会出现一个笔记点赞数连续增加的情况。也就是说，一个笔记赞数加1后，下一个加1的必然是另一个笔记。

现在小红想知道，对于每一个笔记，其赞数变成所有笔记赞数最多时，此时所有的笔记赞数之和的最小值是多少？

**输入描述：**

第一行输入一个正整数n，代表笔记的数量。

第二行输入n个正整数，代表每个笔记当前的赞数。



**输出描述:**

输出n行，每行输出一个整数，代表第i个笔记变成所有笔记赞数最多时，此时所有的笔记赞数之和的最小值。 特殊的，如果第i个笔记永远无法变成赞数最多，则输出-1。

**样例输入:**

```
3
3 1 4
```

**样例输出:**

```
9
15
8
```

**提示:**

对于第一个笔记，当它赞数加1时，赞数达到了4，变成所有笔记赞数最多，此时赞数之和为4+1+4=9。

对于第二个笔记，可以有以下增长方式:2->1->2->1->2->3->2，此时三个笔记的赞数都是5，赞数之和为15。

对于第三个笔记，初始时它的赞数就是最多，此时赞数之和为3+1+4=8。

**思路与代码**

二分答案。

结论1：如果说点赞次数x是偶数，那么是不如x-1的（因为会导致其他的贴子点赞数+1）

结论2：如果点赞x可以，那么x+1就肯定可以，因此具有二段性，可以进行二分。

我们需要判断将某个帖子的点赞数最多的时候，我们二分**点赞的次数**，假设说点赞次数是x，那么当前帖子最多可以被点击x/2 + 1次（如果x是偶数的话，我们直接将x-1），那么如何判断当前帖子是否可以是最大的呢？

1. 当前帖子的点赞数 like + x/2 + 1 是大于等于原帖子的最大值
2. 剩余帖子的总点赞数 + x/2 的**平均数小于等于 like + x/2 + 1.**

```
n = int(input())
likes = [int(x) for x in input().split()]
MX = max(likes)
SUM = sum(likes)
res = [0]*n

# 总点赞数是x的时候，是否可以使得i变为最大值
def check(x,i):
    # 如果x是偶数，我们要让他-1变为奇数
    if x%2==0: x-=1
    diff = x//2 + 1 # 需要增加的点赞数
    cur = SUM - likes[i] + (x-diff) # 排除当前帖子后，其他帖子点赞后的总数
    if diff + likes[i] >= MX and (like[i]+diff)*(n-1) >= cur: return True
    return False

for i,like in enumerate(likes):
    # 将当前的like变为最大
    if len(likes) == 2 and like < mx-1:
        res[i] = -1
        continue
    if like == MX:
        res[i] = SUM
        continue

    # 如何让当前的like变为最大？
    # 如果总点赞数是 x的时候是可行的，那么此时 x+1，x+2，x+3...都是可行的（x必然是奇数）
    # 因此，总点赞数是具有二段型的，可以进行二分。
    l,r = 1, 10**9
    while l < r:
        mid = (l+r)>>1
        if check(mid,i): r = mid
        else: l = mid + 1
    res[i] = SUM + r

print('\n'.join(map(str,res)))
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab） 