**前言**

https://mp.weixin.qq.com/s/iBCPI7KB7A2vLio-IMsEwQ

本场题目难度中等，终于没有麻烦的字符串处理了。

第一题是简单的二叉树遍历题，会建树难度就不大，当然也可以不建树来解决。

第二题是一个排序题，按照规则排序即可，难度也不大，但是需要按照题目的要求进行处理，需要细心。

第三题是强连通分量的问题，当然题目给予了简化，每个节点的出度均为1，所以可以直接跑dfs或者拓扑排序解决。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一进阶提高的活动介绍，有兴趣的同学也可以了解一下！**

### 第一题 满二叉搜索树查找

给定2^n-1个不同的整数(1<=n<=10,n为整数),构建一棵平衡满二叉搜索树

二叉搜索树定义如下: 1)节点的左子树只包含小于当前节点的数。

2)节点的右子树只包含大于当前节点的数。

3)所有左子树和右子树自身必须也是二叉搜索树。例7个数字1234567构建的满二叉搜索树如下所示

```
 4
  2   6
1  3 5  7
```

再给一个待查找数,计算查找路径和结果。

**输入**

输入分2行, 第一行为2^n-1个未排序的整数，空格分隔,用于构建二叉搜索树,其中1<=n<=10

第二行为待查找的整数。

所有输入整数的取值范围为[-32768，32767]。

**输出**

搜索的路径和结果 路径从根节点开始,用S表示,查找左树用L表示，查找右树使用R表示，找到后使用Y表示，最终未找到使用N表示。

**样例1**

**输入:**

```
2 1 3 7 5 6 4
6
```

**输出:**

SRY

解释:从根节点开始，所以路径的第一部分为S，待查找数为6，大于4，所以要查找右树，路径增加R,正好找到。所以最后增加Y,最终输出SRY

**样例2**

**输入:**

```
4 2 1 3 6 5 7
5
```

**输出:**

SRLY

解释：从根节点开始,一次往右树,往左树查找,找到结果5,因此最终SRLY

**样例3**

**输入:**

```
1 2 3 4 5 6 7
8
```

**输出:**

SRRN

解释:从根节点开始查找，标记s，待查找数8比4大,所以查找右树，标记R, 8比6还大，继续查找右树标记R，8比右树节点7还大,但已经到了叶子,没有找到,因此最终标记SRRN

**思路与代码**

本质就是一个二叉搜索树的遍历，不过我们不用建立二叉树，可以用**二分查找**来代替，需要注意的是，访问到叶子节点后，如果还没有找到，此时并不增加路径。

```
#include <sstream>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> v;
int target;

int main()
{
    stringstream ss;
    string s, t;
    getline(cin, s);
    ss << s;
    v.clear();
    while (ss >> t) {
        v.push_back(stoi(t));
    }
   // getchar();
    cin >> target;
    sort(v.begin(), v.end());
    string ans = "S";
    int l = 0, r = v.size() - 1;
    int d = 0;
    while (l <= r) {
        int m = (l + r) / 2;
        d++;
        if (v[m] == target) { ans += "Y"; break; }
        if (v[m] > target) {
            if ((1 << (d)) > v.size()) break;
            ans += "L"; r = m - 1;
        } else {
            if ((1 << (d)) > v.size()) break;
            ans += "R"; l = m + 1;
        }
    }
    if (ans.back() != 'Y') ans += "N";
    cout << ans;
    return 0;
}
```

### 第二题 足球队员射门能力排序

球队有n个足球队员参与m次射门训练，每次射门进球用1表示，射失则用0表示，依据如下规则对该n个队员的射门能力做排序 1、进球总数更多的队员射门能力更强 2、若进球总数—样多，则比较最多—次连续进球的个数，最多的队员能力更强 3、若最多一次连续进球的个数一样多，则比较第一次射失的先后顺序，其中后射失的队员更强，若第一次射失顺序相同，则按继续比较第二次射失的顺序，后丢球的队员能术更强，依次类推 4、若前3个规则排序后还能力相等，则队员编号更小的能力更强

**输入**

第1行，足球队员数n，射门训练次数m。(队员编号从1开始，依次递增) 第2行，第1~n个队员从第1到m次训练的进球情况，每个队员进球情况为连续的1和0的组合，不同队员用空格分隔n和m均为正整数，0<n<=10 ^ 3，0<m<=10^3

**输出**

射门能力从强到弱的队员编号,用空格分隔

**样例1**

**输入:**

```
4 5
11100 0011110111 01111
```

**输出:**

```
4 3 1 2
```

解释:4个队员，射门训练5次，队员3和4进球数均为4个，比队员1和2的3个更多,队员3连续进球数最多一次为3个,而队员4最大为4，因此队员4射门能力强于队员3,另外队员2比队员1先丢球，因此队员1射门能力强于队员2，排序为4312

**样例2**

**输入:**

```
2 10
1011100111 1011101101
```

**输出:**

```
2 1
```

解释:2个队员，射门训练10次，两个队员的进球总数均为7个,连续进球最多的均为3个，且第前两次丢球顺序均为第二次和第6次训练射门，而队员2第三次丢球为第9次训练,队员2为第7次训练，因此队员2的射门能力强于队员1,排序为21

**思路与代码**

本质就是一个排序问题，但是排序的规则比较复杂，需要预处理数据，得到每个人的进球数、最多的连续进球个数、失球顺序，然后排序的时候按照题目要求进行返回即可。

注意输出的时候，最后不需要空格。

```
#include <sstream>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    int n, m; cin >> n >> m;
    vector<int> goals(n, 0), seq(n, 0);
    vector<vector<int>> fs(n);
    for (int i = 0; i < n; ++i) {
        string s; cin >> s;
        int g = 0, mx_s = 0, cur_s = 0;
        for (int j = 0; j < m; ++j) {
            g += (s[j] == '1');
            if (s[j] == '1') ++cur_s;
            else {
                fs[i].push_back(j);
                mx_s = max(mx_s, cur_s); cur_s = 0;
            }
        }
        goals[i] = g; seq[i] = max(mx_s, cur_s);
    }
    vector<int> idx(n);
    for (int i = 0; i < n; ++i) idx[i] = i;
    sort(idx.begin(), idx.end(), [&](auto& a, auto& b) {
        // 进球数
       if (goals[a] > goals[b]) return true;
       if (goals[a] < goals[b]) return false;
        // 最多连续进球数
       if (seq[a] > seq[b]) return true;
       if (seq[a] < seq[b]) return false;
        // 射失顺序
       int sz = fs[a].size();
       for (int j = 0; j < sz; ++j) {
           if (fs[a][j] > fs[b][j]) return true;
           if (fs[a][j] < fs[b][j]) return false;
       }
        return a < b;
    });
    for (int i = 0; i < n; ++i) {
        cout << idx[i] + 1;
        if (i != n - 1) cout << " ";
    }
    return 0;
}
```

### 第三题 找到内聚值最大的微服务群组

开发团队为了调研微服务调用情况,对n个微服务调用数据进行了采集分析,微服务使用数字0至n-1进行编号，给你一个下标从0开始的数组edges , 其中edges[i]表示存在一条从微服务i到微服务edges[i]的接口调用。

我们将形成1个环的多个微服务称为微服务群组，一个微服务群组的所有微服务数量为L，能够访问到该微服务群组的微服务数量为V,这个微服务群组的内聚值H=L-V.

已知提供的数据中有1个或多个微服务群组，请按照内聚值H的结果从大到小的顺序对所有微服务群组(（H相等时，取环中最大的数进行比较)排序，输出排在第一的做服务群组，输出时每个微服务群组输出的起始编号为环中最小的数。

**输入**

入参分为两行输入: 第一行为n,表示有n个微服务 第二行为数组edges,其中edges[i]表示存在一条从微服务i到微服务edges[i]的接口调用，数字以空格分隔

输入范围说明: n== edges.length 2<= n <=10^5 0  <= edges[i] <= n-1

edges[i] !=i

**输出**

输出排在第一的微服务群组的编号数组，按照环的访问顺序输出，起始编号为环中最小的数,数字以空格分隔

**样例1**

**输入：**

```
4
3 3 0 1
```

**输出：**

```
0 3 2
```

解释：

![图片](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/640.webp)

0，3，2组成了微服务群组 (环)a，他的L值为3，对于a来说，只有编号为1的1个微服务可以访问到a,因此a的为1答案输出微服务群组为0 3 2

**样例2**

**输入：**

```
12
2 6 10 1 6 0 3 0 5 4 5 8
```

**输出：**

```
0 2 10 5
```

解释：

![图片](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/640-1715887287894-1.webp)

- 1，6，3组成了微服务群组(环) a1，L1值为3，编号为4、9的2个微服务可以访问到a1,因此√1值为2,H1为L1V1 =1;
- 0，2，10，5组成了微服务群组 (环) a2，L2值为4，编号为7、8、11的3个微服务可以访问到2，因此v2值为3，H2为L2-V2=1；
- 先对比H值,H1=H2,H值相等;
- 再对比环中序号最大值，a1中最大数为6.a2中最大数为10,a2排前面,因此输出答案为:0 2 10 5

**思路与代码**

本题的关键是要找到环，然后对环的内聚值进行排序。至于如何找到环，可以用**拓扑排序**，由于每个节点只有一个出边，所以找环非常简单（重复遍历即可，不需要复杂的dfs或bfs）。由于需要计算内聚值，其中的“能够访问到该微服务群组的微服务数量为V”，也就是连接到该环的节点数，可以在拓扑排序的时候进行累加，最终赋值给环中的各个节点。

排序的时候，按照内聚值和环的最大节点排序；输出的时候，从环的最小节点开始输出。

```
#include <sstream>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
int n; 

int main()
{
    cin >> n;
    vector<int> edges(n);
    vector<int> in(n, 0);
    // 每个节点的子节点数目
    vector<int> nums(n, 0);
    for (int i = 0; i < n; ++i) {
        cin >> edges[i];
        in[edges[i]]++;
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (in[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int sz = q.size();
        while (sz--) {
            int f = q.front(); q.pop();
            in[edges[f]]--;
            nums[edges[f]] += nums[f] + 1;
            if (in[edges[f]] == 0) {
                q.push(edges[f]);
            }
        }
    }
    vector<vector<int>> cir;
    vector<int> value;
    vector<int> mx;
    for (int i = 0; i < n; ++i) {
        if (in[i] == 0) continue;
        int c = i, v = 0, mx_no = i;
        vector<int> path; 
        while (in[c]) {
            v += nums[c];
            path.push_back(c); in[c] = 0;
            c = edges[c];
            mx_no = max(mx_no, c);
        }
        cir.push_back(path);
        mx.push_back(mx_no);
        value.push_back(path.size() - v);
    }
    vector<int> idx(value.size());
    for (int i = 0; i < value.size(); ++i) idx[i] = i;
    sort(idx.begin(), idx.end(), [&](auto& a, auto& b) {
       return value[a] == value[b] ? mx[a] > mx[b] : value[a] > value[b]; 
    });
    auto& path = cir[idx[0]];
    int start = *min_element(path.begin(), path.end());
    for (int i = 0; i < path.size(); ++i) {
        cout << start;
        start = edges[start];
        if (i != path.size() - 1) cout << " ";
    }
    return 0;
}
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab） 