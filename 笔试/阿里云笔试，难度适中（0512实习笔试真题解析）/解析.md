**前言**

https://mp.weixin.qq.com/s/JOPzSpUALO75Gxn32yTXag

本次笔试难度适中。第一题是基础的排列组合问题，比较基础；第二题前缀和枚举即可。第三题树形dp，但是也比较容易。

**春招和暑期实习的笔试也陆陆续续开始啦，有参加笔试的同学欢迎投稿哦，投稿一场完整笔试的，有请你喝一周的奶茶的现金奖励！（投稿加文末微信，备注投稿）**

**文末也有我们的面向校招的一对一进阶提高的活动介绍，有兴趣的同学也可以了解一下！**

## T1

小红定义一个数组是好数组，当且仅当所有奇数出现了奇数次，所有偶数出现了偶数次。现在小红拿到了一个数组，她希望取一个该数组的非空子序列(可以不连续)，使得子序列是好数组。你能帮小红求出子序列的方案数吗?由于答案过大，请对1e9+ 7取模。

**输入描述：**

```
第一行输入一个正整数n，代表数组的大小,第二行输入n个正整数a[i]，代表数组的元素
1<=n<=1e5
1<=a[i]<=1e9
```

**输出描述：**

```
一个整数，代表是“好数组”的子序列数量，对1e9+7取模的值。
```

**示例 1**

```
输入：
4
1 2 3 2
输出: 7
```

#### 思路与代码

对于每个数字，如果该数字为奇数，且该数字一共出现了x次，则出现奇数次的方案数为c(x,1)+c(x,3)+c(x,5)+...+c(x,x).其中c表示组合数，这个大小就是2^(x-1)，但是该数字也可以不出现，所以还要加一，一共就是2^(x-1)+1种方案，而偶数就是c(x,0)+c(x,2)+...c(x,x),这个也是2^(x-1),然后乘起来，再减去全部都不出现的一次，即减去空串的情况，就是最后答案

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int a[100010],pow2[100100];
map<int,int>mp;
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        mp[a[i]]++;
    }
    pow2[0]=1;
    int ans=1;
    for(int i=1;i<=n;i++)pow2[i]=pow2[i-1]*2%mod;
    for(auto i:mp){
        if(i.first&1)
        ans=ans*(pow2[i.second-1]+1)%mod;
        else ans=ans*pow2[i.second-1]%mod;
    }
    cout<<ans-1;
}
```

## T2

定义一个01串为“交错串”，当且仅当任意两个相邻的字符都是不同的。例如，"10101"是交错串. 现在小红拿到了一个01串，她有若干次询问，每次询问一个区间，你需要回答将该区间代表的连续子串修改为“交错串”的最小修改次数。每次修改可以修改任意一个字符。

**输入描述**

```
第一行输入两个正整数n,q，代表字符串长度和询问次数。
第二行输入一个长度为n的、仅由'0'和'1'组成的字符串。
接下来的q行，每行输入两个正整数l,r，代表询问的是第l个字符到第r个字符组成的子串,
1≤n,q≤1e5
1<=l,r<=n
```

**输出描述**

```
输出q行，每行输出一个整数代表询问的答案。
```

**示例1**

```
输入：
6 3
101101
1 3
3 5
1 6
输出：
0
1
3
```

#### 思路与代码

因为一段连续的10串想要变成交错串，不是1010...,就是0101...这两种形式，所以可以先预处理出将这个字符串变成101010..和01010..需要的修改次数，通过前缀和记录，然后查询的时候通过前缀和快速判断这两种较小一种的即可

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int sum1[100010],sum2[100010];
signed main(){
    int n,q;
    cin>>n>>q;
    string s;
    cin>>s;
    s=" "+s;
    for(int i=1;i<s.size();i++){
        sum1[i]=sum1[i-1];
        sum2[i]=sum2[i-1];
        if(i&1){
            if(s[i]!='1')sum1[i]++;
            if(s[i]!='0')sum2[i]++;
        }else {
            if(s[i]!='0')sum1[i]++;
            if(s[i]!='1')sum2[i]++;
        }
    }
    while(q--){
        int l,r;
        cin>>l>>r;
        cout<<min(sum1[r]-sum1[l-1],sum2[r]-sum2[l-1])<<endl;
    }
}
```

## T3

小红拿到了一棵树，她希望选挥两个不相邻且不相同的节点，满足编码的乘积为偶数。请你帮小红求出合法的方案数。我们认为 <x,y> 和<y,x>为同一种方案。

**输入描述：**

```
第一行输入一个正整数n，代表节应数量.
接下来的n-1行，每行输入2个正整数u,v.代表节点u和节点v有一条边连接。
1<=n<=1e5
1<=u,v<=n
```

**输出描述：**

```
一个整数，代表取点的方案数
```

**示例**

```
输入: 
3
1 3
2 3
输出: 
1
```

#### 思路与代码

先算出总共的方案，然后拿总的减去相邻的方案，总共的方案数就是拿偶数点的数量乘奇数点的数量，然后再加上取两个偶数点的情况，然后在统计相邻的乘积为偶数的情况即可

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int num0,num1,ans;
vector<int>e[100010];
void dfs(int u,int f){
    if(u%2==0)num0++;
    else num1++;
    for(auto v:e[u]){
        if(v==f)continue;
        if(u*v%2==0)ans--;
        dfs(v,u);
    }
}
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n-1;i++){
        int u,v;
        cin>>u>>v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs(1,0);
    ans+=num0*num1+(num0-1)*num0/2;
    cout<<ans;
}
```

------

**最后插一下我们的进阶一对一辅导啦** 

> 我们是一个针对技术岗（前后端开发、测试、测开、大数据开发）校招一对一进阶提高的工作室。我们从2020年2月份开始，迄今整整三年的时间，**带领300+学员斩获1500+大厂offer**，参加活动的同学人均5个中大厂offer以上，以下是我们活动内容的介绍！
>
> 万诺coding

我们主要是针对有一定基础的同学提供**一对一面试辅导**，针对每个同学不同的情况定制内容，包括但不限于“**数据结构与算法”/“计算机基础知识”/“项目梳理”/“面试技巧”/“面试复盘**”等内容。

**摸底测试**：如果有兴趣深入了解我们的活动，需要先参加我们的“摸底测试”（类似面试），方便我们了解你的具体情况（**主要是code能力和计算机素养**），定制出相应的辅导计划。同时这也是一个双向筛选的过程，如果基础过差的同学，抱歉我们可能无法辅导（基础过差的同学一对一辅导成本过高，对双方都不适合）；摸底测试通过的同学，我们会定制化一个针对性的提高计划。**然后你再考虑是否参加我们的活动**。 

**承诺保offer**：通过摸底测试后，我们会针对每个同学的情况给定一个“保offer”计划。**然后同学可以根据自己的实际情况考虑参不参加我们的活动**。

有兴趣的同学可以扫码添加我们的微信（whynotlab） 