// 创建深拷贝的函数，参数1是被复制的对象，参数2是一个WeakMap，用于存储已经复制过的对象，防止循环引用
function deepCopy(obj, cache = new WeakMap()) {
  // 如果obj不是对象，直接返回值
  // 为什么？因为我要设计一个深拷贝，如果你是基本数据类型，你在栈内存里，你就不需要深拷贝，因为你是浅拷贝，所以就直接返回你本身就可以了，这个第一步是做一个判断，判断你是不是引用数据类型，是的话再继续
  if (!obj instanceof Object) return obj
  // 如果这个对象已经被复制过，直接返回之前复制的版本
  // 这一步是为了处理循环引用的情况。
  // 在 JavaScript 中，一个对象可以包含对其他对象的引用，如果你有一个对象，它的一个属性指向了自身或者是一个循环的引用关系，那么，当你试图做深拷贝的时候，如果没有特殊处理，你的代码会陷入无限循环中。
  // 所以在 deepCopy 函数中引入了一个 cache 的 WeakMap。WeakMap 是一种特殊的 Map，它的键只能是对象，而且当对象被垃圾回收的时候，对应的 WeakMap 记录也会被移除。这样做不会造成内存泄露。
  // 代码中 cache.get(obj) 的操作就是去查看这个对象是否已经被复制过（也就是 cache 中有没有对这个对象的记录），如果已经被复制过，那么就直接返回之前复制的版本，从而避免了无限的循环引用。如果没有被复制过，继续后面的逻辑来复制这个对象，并把这个新复制出来的对象保存到 cache 中。
  if (cache.get(obj)) return cache.get(obj)

  // 下面开始进行深拷贝

  // 如果是函数，就创建一个新的函数，并保留原函数的作用域
  // 这一步的目的是确保在对对象做深复制时，对象内部的任何函数也被正确地复制，且新的函数能够行为与原函数完全一样。当复制了一个引用其他变量的函数（也就是一个闭包）时，只复制函数的定义是不够的，因为函数中可能会访问在它定义当时的作用域中的一些变量。
  // 通过创建一个新的函数，并通过 'apply' 方法来调用原函数，这样做可以确保即使在新的上下文中，被复制的函数仍然可以访问到原函数的作用域。这样，无论函数是简单的函数还是复杂的闭包，都可以被成功复制，并保持原有的行为和功能。
  // 这样，无论原对象的结构多么复杂（包括有闭包函数、循环引用等），深复制操作都可以完全复制所有的部分，而不会改变复制出来的对象的功能。这对于一些需要保留原有对象状态，又需要操作新状态的场景（比如撤销操作，状态保存等）来说，是非常有用的。
  if (obj instanceof Function) {
    return function () {
      return obj.apply(this, arguments)
    }
  }

  // 如果是日期，就返回一个新的日期对象，日期值和原日期一样
  if (obj instanceof Date) return new Date(obj)

  // 如果是正则表达式，就创建一个具有相同规则和标志的新正则表达式
  // 写 return new RegExp 是不够的，这个构造函数需要传入参数来指定正则表达式的模式和标记。
  // 当你对一个正则表达式对象用 new RegExp 创建新的实例但不传入任何参数时，你将得到的是一个完全新的、规则为空的正则表达式，它与原有的正则表达式无关。
  // 写 return new RegExp(obj.source, obj.flags) 的目的是为了克隆原有的正则表达式。obj.source 和 obj.flags 这两个参数分别代表原正则表达式的规则（比如匹配的文本模式）和标记（比如是否全局匹配，是否区分大小写等）。通过将它们传入 new RegExp，我们能得到一个新的、规则和标记都与原来完全一样的正则表达式。
  // 简单地说，return new RegExp没有参数，你无法复制原始正则表达式的行为。而 return new RegExp(obj.source, obj.flags) 可以确保新正则表达式的行为与原正则表达式相同。
  // source 和 flags 是正则表达式对象的两个内置属性。
  // source：这个属性包含了正则表达式的文本模式。比如说，对于 /abc/g 这个正则表达式，它的 source 就是 "abc"。
  // flags：这个属性包含了正则表达式的标志，这些标志定义了一些匹配行为。比如说，"g" 表示全局匹配，"i" 表示不区分大小写，"m" 表示多行匹配等。对于 /abc/g，它的 flags 就是 "g"。
  // 这两个就是正则表达式最常用的属性了。
  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags)

  // 上面处理了函数、日期、正则表达式
  // 下面负责处理数组、函数
  // 新建一个空数组或对象，准备用来接收复制过来的属性
  const res = Array.isArray(obj) ? [] : {}
  // 将这个空数组或对象存入cache，表示obj已经被复制过了
  // 在这段代码中，cache.set(obj, res) 是用来将原对象 obj 和它的拷贝 res 相关联起来的。这样我们就可以知道这个对象已经被拷贝过了

  // 这在处理循环引用的情况下非常有用。举个例子，如果对象 obj 中有一个属性 cycle，它的值引用了 obj 本身，我们可以写成这样的形式：obj.cycle = obj。在这种情况下，如果不记录哪些对象已经被拷贝过，那么深拷贝的过程将会陷入到一个无限的循环中，因为它会一直试图拷贝 obj.cycle，然后又回到拷贝 obj，如此反复。

  // 因此，cache.set(obj, res) 函数就是在告知我们的深拷贝函数，obj 已经被拷贝过了，如果再次遇到 obj 的话，我们可以直接使用已经拷贝过的结果，而不是再次尝试拷贝一次。这样就解决了循环引用导致的无限循环问题。
  cache.set(obj, res)

  // 遍历obj中所有的键
  // 获取 obj 对象的所有键并遍历它们。
  Object.keys(obj).forEach((key) => {
    // 然后，在每次遍历的过程中，都会检查当前键（key）对应的值（obj[key]）是否为对象类型。这是通过 obj[key] instanceof Object 检查的。
    // 如果属性值是对象，就递归调用deepCopy函数
    if (obj[key] instanceof Object) {
      // 如果 obj[key] 是对象类型，那么就递归调用 deepCopy 函数对其进行深拷贝。所谓“递归调用”是指函数在执行过程中，调用了自身进行执行。在这里，deepCopy 函数就在自身的实现中调用了自己（res[key] = deepCopy(obj[key], cache)），并传入了 obj[key] 对象，以实现对 obj[key] 的深拷贝。
      // 为啥要递归调用？因为这是一个对象，所以里面还有对象，所以要递归调用
      res[key] = deepCopy(obj[key], cache)
    } else {
      // 如果不是对象，就直接复制值过来
      // 如果 obj[key] 不是对象类型，那么就直接将 obj[key] 的值复制到 res[key]。实现原理就是把一个原始类型值（如字符串、数值、布尔值等）直接赋值给新对象 res 的同名属性。
      // 这里获取到值了，直接获取到基本数据类型了
      res[key] = obj[key]
    }
  })
  // 这个过程会对每一个对象的属性进行上述操作，直到对象的所有属性都被遍历完。这样就实现了一个对象的深拷贝，即创建了一个新的对象 res，它的结构和 obj 完全相同，但是 res 和 obj 是完全独立的两个对象，修改 res 不会影响 obj，反之亦然。
  // 最后，这段代码将新创建的对象（即深拷贝的结果）res 返回，这样调用者就可以得到这个深拷贝后的对象了。
  return res
}

// 创建一个对象做测试
const source = {
  name: 'Jack',
  meta: {
    age: 12,
    birth: new Date('1997-10-10'),
    ary: [1, 2, { a: 1 }],
    say() {
      console.log('Hello')
    },
  },
}

// 给对象加了一个属性，这个属性等于对象本身，形成循环引用
source.source = source

// 使用深拷贝函数创建新对象
const newObj = deepCopy(source)

// 检查深拷贝是否成功，期望所有的引用类型属性都不再指向原来的对象，而是指向复制出来的新对象
console.log(newObj.meta.ary[2] === source.meta.ary[2]) // false
console.log(newObj.meta.birth === source.meta.birth) // false
