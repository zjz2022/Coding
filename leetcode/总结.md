> 熟记下面这些题目的
>
> 最优解思路+代码+时间复杂度分析

# 哈希

## 两数之和 	

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  // 创建一个表，用来存放数组中的元素及其在数组中的下标
  let map = new Map()

  // 遍历数组
  for (let i = 0; i < nums.length; i++) {
    let k = target - nums[i] // 计算目标差值

    // 如果表中已经存在差值，则找到了符合条件的两个元素
    if (map.has(k)) {
      // map.get(k) 是第一个元素的数组下标， i 是当前元素的数组下标
      return [map.get(k), i]
    }

    // 将当前元素及其在数组中的下标存入表中
    map.set(nums[i], i)
  }

  // 如果没有找到符合条件的两个元素，返回空数组
  return []
}

console.log(twoSum([2, 3, 6, 7, 8], 10))
```

## 字母异位词分组

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
// 定义一个名为groupAnagrams的函数，接收一个string类型的数组，返回一个二维string数组。
var groupAnagrams = function (strs) {
  // 创建一个Map对象，键为排序后的字符串，值为几个不同的原字符串（排序后都一样）的数组
  const map = new Map()

  // 遍历传入的strs数组
  for (let str of strs) {
    // 对当前字符串的每个字符进行排序，并转化为字符串作为键
    const key = [...str].sort().toString()

    // 检查map中是否有当前键，如果有，取出对应的值（值为数组），否则创建一个新的空数组
    const list = map.get(key) ? map.get(key) : []

    // 往这个数组中添加当前遍历的字符串
    list.push(str)

    // 在map中设置当前键和其对应的值（值为包含当前字符串的数组）
    map.set(key, list)
  }

  // 将map的所有值（即所有的字符串数组）转换为数组并返回

  return Array.from(map.values())
  // map.values() { [ 'cog', 'ocg', 'goc' ], [ 'dog', 'god' ] } 是一个对象哦！ 这里用 Array.from 就相当于把 {} 换成了 []
}

// @lc code=end

console.log(groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']))
//  输出：[["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

## 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {
  // 转化成哈希集合，为了快速查找哈希集合中是否存在某个元素。
  // 因为在哈希集合中查找元素的时间复杂度为O(1)，从而提高了算法的效率。
  let set = new Set(nums)

  // 初始化最长连续子序列的长度为0
  let res = 0

  // 对哈希集合中的每个元素进行迭代
  for (let num of set) {
    // 如果num-1存在于集合中，说明num不是连续子序列的第一个元素，
    // 所以我们继续下一个元素的迭代，寻找新的序列的可能起点
    if (set.has(num - 1)) continue

    // 如果num-1不存在于集合中，说明num可以作为一个新的连续子序列的起点，
    // 因此开始向下一个元素进行检索，并计算连续子序列的长度
    let curNum = num // 当前判断的数字
    let curLen = 1 // 初始化当前序列长度为1

    // 如果集合中存在curNum+1，将curNum更新为curNum+1，并将当前长度加1
    // 循环此过程，直到集合中不存在curNum+1为止
    while (set.has(curNum + 1)) {
      curNum += 1
      curLen += 1
    }
    // 比较并更新已知的最长连续子序列长度
    // Math.max是取两个参数中的最大值
    res = Math.max(res, curLen)
  }

  // 返回最长连续子序列的长度
  return res
}
// @lc code=end

console.log(longestConsecutive([100, 4, 200, 1, 3, 2]))
```



# 二叉树

## 二叉树的中序遍历

## 二叉树的最大深度

## 翻转二叉树

## 对称二叉树

## 二叉树的直径

## 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
/*
 */
var levelOrder = function (root) {
  // 如果树的根节点为空（即树为空），那么函数会立即返回一个空数组。
  if (!root) return []
  // 定义了存储结果的数组 result，以及队列长度的变量 len（初始值为0），并将根节点放入队列 queue 中。
  let result = []
  let len = 0,
    // 这一步是在创建一个队列queue，并把二叉树的根节点root作为队列的第一个元素。队列是一种特殊的列表，只能在列表的一端（称为队尾）插入元素，在另一端（称为队头）移除元素。
    // queue = [root]这一步操作实际上就是初始化了一个队列，并把二叉树的根节点放入了这个队列。
    queue = [root]
  // 当队列不为空，即还有节点待处理时，进入循环。
  while (queue.length > 0) {
    // 获取当前队列的长度，即当前层的节点数。
    len = queue.length
    // 在结果数组中添加一个新的子数组，用于存放当前层的节点值。
    result.push([])
    // 遍历当前层的所有节点，将它们从队列中移出，同时将它们的值添加到结果数组的最末尾子数组中。如果这些节点有左孩子或右孩子，就将这些孩子节点加入到队列中。
    while (len--) {
      // shift是移除数组头部元素，并返回该元素的值
      const n = queue.shift()
      // 负数索引表示从数组的末尾开始计数，这里最后一个元素是一个数组，我是要添加到这个数组里面，所以我才要写 result.at(-1)
      // push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
      // 这一步就是，在result数组的最后一个数组里面，添加n.val
      result.at(-1).push(n.val)
      // 如果 n.left 存在（即不为 null 或 undefined），则执行 queue.push(n.left)，即把 n.left 放入队列 queue 中
      n.left && queue.push(n.left)
      // 同理，如果右边有值，就存入队列中
      n.right && queue.push(n.right)
    }
  }
  // 在处理完所有层之后，返回结果数组。
  return result
  // 所以，最终函数返回的是一个二维数组，其中每个子数组保存了树中对应层级的所有节点值。
}

// @lc code=end

function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val
  this.left = left === undefined ? null : left
  this.right = right === undefined ? null : right
}

// 创建一个测试用的 TreeNode
let root = new TreeNode(
  3,
  new TreeNode(9),
  new TreeNode(20, new TreeNode(15), new TreeNode(7))
)

// 测试 levelOrder 函数
console.log(levelOrder(root)) // 期望输出： [[3], [9,20], [15,7]]
```

## 将有序数组转换为二叉搜索树

## 验证二叉搜索树

## 二叉搜索树中第K小的元素

## 二叉树的右视图

## 二叉树展开为链表

## 从前序与中序遍历序列构造二叉树

## 路径总和Ⅲ

## 二叉树的最近公共祖先

## 二叉树中的最大路径和

## 根节点到叶节点数字之和

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/num1tree.jpg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 建立的主要函数，用于求得所有路径之和
var sumNumbers = function (root) {
  let sum = 0
  const dfs = function (root, total) {
    if (!root.left && !root.right) {
      sum = sum + (total - 0)
      return
    }
    if (root.left) {
      dfs(root.left, total + '' + root.left.val)
    }
    if (root.right) {
      dfs(root.right, total + '' + root.right.val)
    }
  }
  dfs(root, root.val)
  return sum
}

// @lc code=end

function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val
  this.left = left === undefined ? null : left
  this.right = right === undefined ? null : right
}
// 创建一个测试用的 TreeNode
let root = new TreeNode(1, new TreeNode(2), new TreeNode(3))

// 测试 levelOrder 函数
console.log(sumNumbers(root)) // 期望输出： 25
```

# 链表

## 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
// 双指针  时间复杂度 O(m+n),空间复杂度 O(1)
// 核心逻辑：消除长度差
// 1. 假设相交链表长度为 c，链表A为为长链表，则 长链表长度=a+c; 链表 B 为短链表，则短链表长度=b+c
// 2. 长链表和短链表同时向前走，当短链表走到末尾的时候，此时双方各自都走过的是短链表的长度，
// 3. 此时将短链表指向长链表，接着往下走，当长链表走到末尾的时候，此时双方各自都走过长链表的长度
// 4. 短链表走过的是长链表后半段（短链表的长度）和长链表前半段（长链表长度-短链表长度）。
// 5. 此时将长链表指向短链表头部，短链表指向下一个节点（刚好与短链表指向的位置重合，即后面的长度都一致）
// 6. 这样就可以一直往下遍历，来判断当两个链表值一致即返回，null=null 也会返回。

var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB){
        return null;
    }
    // 双指针
    let p1 = headA;
    let p2 = headB;
    while(p1 !== p2 ){
        p1 = p1 === null ? headB : p1.next;
        p2 = p2 === null ? headA : p2.next;
    }
    return p1
};
```

## 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
// 方法二：数组法
// 复杂度分析
// 时间复杂度：O(n)，其中 n 指的是链表的元素个数。
// 第一步：遍历链表并将值复制到数组中，O(n)。
// 第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
// 总的时间复杂度：O(2n) = O(n)。
// 空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。
var isPalindrome = function (head) {
  if (!head || !head.next) {
    return true
  }
  let arr = []
  while (head) {
    arr.push(head.val)
    head = head.next
  }
  let len = arr.length
  for (let i = 0, j = len - 1; i < len, j > 0; i++, j--) {
    if (arr[i] !== arr[j]) {
      return false
    }
  }
  return true
}
// @lc code=end

console.log(isPalindrome([1, 2, 2, 1]))
```

## 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  // 快慢指针是解决环形链表的不二法门
  let fast = head
  let slow = head

  while (fast) {
    if (fast.next === null) {
      return false
    }
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) return true
  }

  return false
}
```

## 环形链表Ⅱ

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/circularlinkedlist-1717072101181-14.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  // 定义一个哈希表，用来存储节点
  var set = new Set()

  // 遍历链表，当链表里没有的时候，就插入到哈希表中。即将整个链表都放入哈希表中
  while (head) {
    if (!set.has(head)) {
      set.add(head)
    } else {
      // 如果哈希表里存在，就证明有环,返回下标
      return head
    }
    head = head.next
  }
  return null
}
// @lc code=end
```

## 随机链表的复制

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

```js
/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function (head) {
  if (!head) return null
  let cur = head
  let cNode = null // while 循环外初始化复制节点，避免每次都声明
  while (cur) {
    let next = cur.next // 保存cur.next不丢失
    cNode = new Node(cur.val, next, cur.random) // 复制原有节点
    cur.next = cNode // cur连接复制的cNode节点，为什么没写cNode.next = cur.next? 因为在Node方法里已经做了这一步
    cur = next
  } // 每个复制节点都会跟在原节点后面
  cur = head.next // 让cur指向head的下一个节点，也就是复制节点，因为我们用从复制节点开始纠正随机指针
  while (cur) {
    cur.random && (cur.random = cur.random.next) // 随机指针指向的节点后也是有复制节点，如果cur有随机指针，我们就让cur.random指向原节点随机指针指向节点的复制节点即可
    ;(cur = cur.next) && (cur = cur.next) // 每间隔一位才是复制节点
  }
  let temp = head.next // 保存一下head.next作为我们复制链表的头节点返回
  cur = head.next // 操作cur指针拆出我们的复制链表
  while (cur.next) {
    // 当cur.next 为null也就是已经遍历到最后一个复制节点了
    let next = head.next.next
    let temp = cur.next.next
    head.next = head.next.next // 让head连接head的下下个节点
    cur.next = cur.next.next // 让cur连接cur的下下个节点，cur与head间隔相连，拆成两条链表
    cur = temp
    head = next
  }
  head.next = null // 复制节点是最后一个节点不用指向null,head为复制节点的前一个节点需要断开去指向null,拆解完毕
  return temp
}
// @lc code=end
```

## 排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function (head) {
  // 将链表中的next指针打断，放入数组中
  let res = []
  if (!head) return null // 返回的是空节点，不是空数组

  while (head) {
    res.push(head)
    let temp = head.next
    head.next = null
    head = temp
  }
  // 排序链表中的值，然后进行拼接
  res.sort((a, b) => a.val - b.val).reduce((p, c) => (p.next = c))
  return res[0]
}
// @lc code=end
```

## 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
  // p1 和 p2 是遍历两条链表的指针
  let p1 = l1,
    p2 = l2

  // dummy 是一个虚拟节点，p 是用于构建结果链表的指针
  let dummy = new ListNode(-1)
  let p = dummy

  // carry 用于存储进位
  let carry = 0

  // 只要链表 l1 和 l2 不为空，或者还有进位，就一直循环
  while (p1 !== null || p2 !== null || carry > 0) {
    // 初始化本次加和的结果为 carry
    let val = carry

    if (p1 !== null) {
      val += p1.val // 加上链表 l1 对应节点的值
      p1 = p1.next // p1 指针向前移
    }

    if (p2 !== null) {
      val += p2.val // 加上链表 l2 对应节点的值
      p2 = p2.next // p2 指针向前移
    }

    // 计算进位
    carry = Math.floor(val / 10)
    // 本节点的值应该是对10取余的结果
    val = val % 10

    // 新建一个节点存储本次加和的结果，加入到结果链表中
    p.next = new ListNode(val)
    p = p.next
  }

  // 返回结果链表（去除第一位的虚拟节点）
  return dummy.next
}

// @lc code=end

// 定义链表
function ListNode(val) {
  this.val = val
  this.next = null
}

// 构造链表2->4->3
let l1 = new ListNode(2)
l1.next = new ListNode(4)
l1.next.next = new ListNode(3)

// 构造链表5->6->4
let l2 = new ListNode(5)
l2.next = new ListNode(6)
l2.next.next = new ListNode(4)

// 按照题目要求处理两个链表
let node = addTwoNumbers(l1, l2)

// 根据定义的链表，输出链表，自测结果
while (node !== null) {
  console.log(node.val)
  node = node.next
}

/*
7
0
8
*/
```

## 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
  // 删除链表的倒数第N个节点是一个典型的双指针问题
  let slow = head
  let fast = head
  let temp = head
  // 第一步：让快指针先走n步
  let count = n + 1
  while (count && fast) {
    fast = fast.next
    count--
  }
  if (!fast && count) {
    while (count) {
      slow = slow.next
      count--
    }
    return slow
  }
  while (fast) {
    fast = fast.next
    slow = slow.next
  }
  let stemp = slow.next.next
  slow.next = stemp
  return temp
}
// @lc code=end

// 定义链表,leetcode推荐的
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

// 构造链表1->2->3->4->5
let l1 = new ListNode(1)
l1.next = new ListNode(2)
l1.next.next = new ListNode(3)
l1.next.next.next = new ListNode(4)
l1.next.next.next.next = new ListNode(5)

// 按照题目要求处理两个链表（以链表相加为例）
let node = removeNthFromEnd(l1, 2)

// 根据定义的链表，输出链表，遍历节点，输出每个节点的值
while (node !== null) {
  console.log(node.val)
  node = node.next
}

```

## K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

```js
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function (head, k) {
  // 首先判断传入的链表的长度是否小于k，如果小于k，则返回原链表
  let flag = 0
  let temp = head
  while (temp) {
    temp = temp.next
    flag++
  }
  if (flag < k) {
    return head
  }
  // 初始化指针
  let prev = null
  let cur = head
  let n = k
  while (cur != null && n-- > 0) {
    // 首先保存后一个节点
    let next = cur.next
    // cur指针的next域指向前一个节点
    cur.next = prev
    prev = cur
    cur = next
  }
  // 修改head指针的next域指向递归的返回结果
  head.next = reverseKGroup(cur, k)
  return prev
}
// @lc code=end

function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

let l1 = new ListNode(1)
l1.next = new ListNode(2)
l1.next.next = new ListNode(3)
l1.next.next.next = new ListNode(4)
l1.next.next.next.next = new ListNode(5)

let node = reverseKGroup(l1, 3)

while (node !== null) {
  console.log(node.val)
  node = node.next
}
```

## 合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

```js
var mergeKLists = function (lists) {
  // 暴力法
  if (lists.length === 0) return null
  const res = []
  for (let v of lists) {
    while (v) {
      res.push(v.val)
      v = v.next
    }
  }
  if (res.length === 0) return null
  res.sort((num1, num2) => num1 - num2)
  const temp = []
  for (let v of res) {
    temp.push(new ListNode(v))
  }
  for (let i = 0; i < temp.length - 1; i++) {
    temp[i].next = temp[i + 1]
  }
  temp[temp.length - 1].next = null
  return temp[0]
}
// @lc code=end
```

## LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

```js
/*
 * @lc app=leetcode.cn id=146 lang=javascript
 *
 * [146] LRU 缓存
 */

// @lc code=start
/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {
  this.capacity = capacity
  this.map = new Map()
}

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {
  // 如果map中有这个key存在则返回，反之返回-1
  if (this.map.has(key)) {
    const value = this.map.get(key)
    this.map.delete(key)
    this.map.set(key, value)
    return this.map.get(key)
  } else {
    return -1
  }
}

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {
  // 首先判断这个key存在吗，存在则删除，重新放置 反之直接放置
  if (this.map.has(key)) {
    this.map.delete(key)
    this.map.set(key, value)
  } else {
    // 判断map的大小是否比题目给定的容量大
    if (this.map.size >= this.capacity) {
      this.map.delete(this.map.entries().next().value[0])
      this.map.set(key, value)
    } else {
      this.map.set(key, value)
    }
  }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
// @lc code=end

// ["LRUCache","put","put","get","put","get","put","get","get","get"]
// [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
const lruCache = new LRUCache(2)
lruCache.put(1, 1)
lruCache.put(2, 2)
const res1 = lruCache.get(1)
lruCache.put(3, 3)
const res2 = lruCache.get(2)
lruCache.put(4, 4)
const res3 = lruCache.get(1)
const res4 = lruCache.get(3)
const res5 = lruCache.get(4)

console.log(res1, res2, res3, res4, res5)
// 1 -1(undefined) -1(undefined) 3 4

```



## 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function (l1, l2) {
  // 虚拟头结点
  var dummy = new ListNode(-1),
    p = dummy
  var p1 = l1,
    p2 = l2

  while (p1 !== null && p2 !== null) {
    // 比较 p1 和 p2 两个指针
    // 将值较小的的节点接到 p 指针
    if (p1.val > p2.val) {
      p.next = p2
      p2 = p2.next
    } else {
      p.next = p1
      p1 = p1.next
    }
    // p 指针不断前进
    p = p.next
  }

  if (p1 !== null) {
    p.next = p1
  }

  if (p2 !== null) {
    p.next = p2
  }

  return dummy.next
}

// 首先定义一个ListNode构造函数
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

// 创建第一个链表：1 -> 2 -> 4
var l1 = new ListNode(1)
l1.next = new ListNode(2)
l1.next.next = new ListNode(4)

// 创建第二个链表：1 -> 3 -> 4
var l2 = new ListNode(1)
l2.next = new ListNode(3)
l2.next.next = new ListNode(4)

var node = mergeTwoLists(l1, l2)
while (node !== null) {
  console.log(node.val)
  node = node.next
}

/* 
结果
1
1
2
3
4
4 
*/
```

## 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

```js
// 定义一个名为 reverseList 的函数，其参数为链表的头节点 head
var reverseList = function (head) {
  // 初始化两个指针节点，a 和 b，同时初始化临时节点 c
    let cur = head;
    let pre = null;

    while (cur) {
        // 首先保存当前节点的下一个节点
        let temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}

// @lc code=end
function ListNode(val) {
  this.val = val
  this.next = null
}

let l1 = new ListNode(1)
l1.next = new ListNode(2)
l1.next.next = new ListNode(3)
l1.next.next.next = new ListNode(4)
l1.next.next.next.next = new ListNode(5)

let node = reverseList(l1)
while (node !== null) {
  console.log(node.val)
  node = node.next
}
```

# 普通数组

## 最大子数组和

## 合并区间

## 轮转数组

## 除自身以外数组的乘积

## 缺失的第一个正数

# 矩阵

## 矩阵置零

## 螺旋矩阵

## 旋转图像

## 搜索二维矩阵Ⅱ

# 滑动窗口

## 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。	

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  let window = new Map() // 创建一个 Map 来储存字符及其出现次数。
  let left = 0,
    right = 0,
    res = 0 // 初始化左、右指针和结果值。
  while (right < s.length) {
    // 当右指针还没有到达字符串的尾端时，继续循环。
    let c = s[right] // 取出右指针所在位置的字符。
    right++ // 向右移动右指针。
    // 在一个表达式 A || B 中，如果 A 为真（也就是 Boolean 值为 true），则返回 A 的值。否则，返回 B 的值。
    window.set(c, (window.get(c) || 0) + 1) // 在 Map 中更新此字符的计数，如果字符不存在，则初始化其计数为 1。
    while (window.get(c) > 1) {
      // 当字符的计数大于1时（说明字符重复），因此需要收缩窗口。
      let d = s[left] // 取出左指针所在位置的字符。
      left++ // 向右移动左指针，也就是收缩窗口。
      // 左指针会一直移动，穿过所有的 d，直到它碰到 c，便会停下来。这样，我们就成功地消除了窗口内的重复字符，保证了窗口内的所有字符都是唯一的。
      window.set(d, window.get(d) - 1) // 在Map中更新此字符的计数，减小其计数值。
    }
    res = Math.max(res, right - left) // 更新最大无重复字符子串的长度，取当前最大长度和新窗口长度的较大值。
  }
  return res // 返回最大无重复字符子串的长度。
}
// @lc code=end
console.log(lengthOfLongestSubstring('abcabcbb'))
```

## 找到字符串中所有字母异位词

# 双指针

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

## 移动零

```js
/**
 * @param {number[]} nums
 * @return {any} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let slowIndex = 0
  for (let fastIndex = 0; fastIndex < nums.length; fastIndex++) {
    if (nums[fastIndex] !== 0) {
      ;[nums[fastIndex], nums[slowIndex]] = [nums[slowIndex], nums[fastIndex]]
      slowIndex++
    }
  }
  return nums
}
// @lc code=end

console.log(moveZeroes([0, 1, 0, 3, 12]))
```



## 盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
  let l = 0,
    r = height.length - 1
  let ans = Math.min(height[l], height[r]) * (r - l)
  while (l < r) {
    if (height[l] < height[r]) l++
    else r--
    ans = Math.max(ans, Math.min(height[l], height[r]) * (r - l))
  }
  return ans
}
// @lc code=end

console.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]))
```



## 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  nums.sort((a, b) => a - b)
  let ans = []
  for (let i = 0; i < nums.length; i++) {
    // i && 是为了防止在 i = 0 时去比较 nums[0] 和 nums[-1]
    if (i && nums[i] == nums[i - 1]) continue
    let j = i + 1,
      k = nums.length - 1
    while (j < k) {
      let sum = nums[j] + nums[k]
      if (sum == -nums[i]) {
        ans.push([nums[i], nums[j], nums[k]])
        // j++后，我从nums[j]移动到了nums[j+1]上，还是同一个值，没变
        while (j < k && nums[j] == nums[j + 1]) j++
        while (j < k && nums[k] == nums[k - 1]) k--
        // 所以我要改变值，就要j++
        j++
        k--
      } else if (sum < -nums[i]) {
        j++
      } else {
        k--
      }
    }
  }
  return ans
}

// @lc code=end

console.log(threeSum([-1, 0, 1, 2, -1, -4]))
```

**思路+时间复杂度**

看起来你分享了一个在JavaScript中解决 "3Sum"算法题的方法。这是一个经典的双指针技巧应用题。给定包含n个整数的数组nums，你的解决方案是寻找数组中是否存在三个元素a, b, c，使得b + c = -a，并返回所有满足条件且不重复的三元组。

你的解决方案大致过程如下：

1. 首先，你将数组进行了从小到大的排序。
2. 然后，你遍历了整个数组，如果当前的元素和前一个元素相同，你会跳过这个元素以避免重复的三元组出现。
3. 对于每一个不同的元素，你都设置了两个指针，一个指向它后面的第一个元素，另一个指向数组的最后一个元素。然后，你开始移动这两个指针，寻找能满足三数之和为0的情况。
4. 如果三数之和小于0，你就让前面的指针向后移动一位（因为数组是有序的，所以这样可以让三数之和变大）。如果三数之和大于0，你就让后面的指针向前移动一位（可以让三数之和变小）。
5. 当两个指针未相遇，并找到三数之和为0的情况时，你把这三个数添加进结果数组中。然后你移动两个指针，跳过所有相同的元素，以避免重复的三元组出现。

这个方法的时间复杂度为O(n^2)，因为需要对每个元素进行一次两层循环的确证。其中n为数组的长度。

## 接雨水

# 子串

## 和为K的子数组

## 滑动窗口最大值

## 最小覆盖子串

# 图论

## 岛屿数量

## 腐烂的橘子

## 课程表

## 实现 Trie（前缀树）

# 回溯

## 全排列

## 子集

## 电话号码的字母组合

## 组合总和

## 括号生成

## 单词搜索

## 分割回文串

## N皇后

# 二分查找

## 搜索插入位置

## 搜索二维矩阵

## 在排序数组中查找元素的第一个和最后一个位置

## 搜索旋转排序数组

## 寻找旋转排序数组中的最小值

## 寻找两个正序数组的中位数

# 栈

## 有效的括号

## 最小栈

## 字符串解码

## 每日温度

## 柱状图中最大的矩形

# 堆

## 数组中第K个最大元素

## 前K个高频元素

## 数据流的中位数

# 贪心算法

## 买卖股票的最佳时机

```js
var maxProfit = function (prices) {
  const len = prices.length
  let maxProfit = 0,
    maxPrice = prices[len - 1]
  for (let i = len - 2; i >= 0; i--) {
    maxProfit = Math.max(maxProfit, maxPrice - prices[i])
    maxPrice = Math.max(maxPrice, prices[i])
  }
  return maxProfit
}

/*
这段代码是一个寻找最大利润的算法，股票价格存储在一个数组prices之中。算法的主要目标是找到最佳的买入和卖出时间，以此获得最大利润。

现在我将以一种算法可视化的方式描述这段代码的运行过程。

1. 起始状态：这里我们有一个数组prices，它表示每一天的股票价格。maxPrice的初始值是数组最后一项的值，表示未来的最高价格。maxProfit初始化为0，表示当前的最大利润。

2. 开始反向遍历数组：从倒数第二个元素开始，算法会逐一检查每一个元素。在每一步中，都会尝试计算出如果在这一天买入股票（prices[i]），然后在未来的最高价（maxPrice）卖出，能得到多少利润（maxPrice - prices[i]）。

3. 更新最大利润和最高价格：如果新计算出的利润大于当前的最大利润，则更新maxProfit。同时，我们还需要更新maxPrice，使其始终保持是当前元素之后的最大元素值，也就是说在当前日期之后的可以卖出的最高价格。

4. 结束后返回最大利润：遍历完成后，maxProfit就是我们可以通过买卖股票获取的最大利润。

可视化表示如下（以prices = [7,1,5,3,6,4]为例）：

- 初始状态：
    - maxPrice = 4（prices最后一项），maxProfit = 0
    - prices = [7,1,5,3,6,4]

- 第一步（i=4）：
    - prices[i] = 6，尝试计算利润： maxPrice - prices[i] = 4 - 6 = -2。这是一个亏本的交易，所以我们不会更新maxProfit。
    - 因为prices[i] > maxPrice，所以更新maxPrice = 6。

- 第二步（i=3）：
    - prices[i] = 3，尝试计算利润：maxPrice - prices[i] = 6 - 3 = 3。这比当前的maxProfit大，所以我们更新maxProfit = 3。
    - 因为prices[i] < maxPrice，所以maxPrice保持不变。

- 第三步（i=2）...
    - 以此类推，一直到i=0，也就是价格数组的开始。

在这整个过程中，通过反向遍历和不断更新maxPrice和maxProfit，保证了每次都是以最高可能的价格售出股票，从而最终得到最大可能的利润。并且，由于这个算法只需要遍历一遍数组，所以时间复杂度是O(n)。
*/
```

## 跳跃游戏

```js
var canJump = function (nums) {
  if (nums.length == 1) return true
  // 在现在这个位置上，需要移动count次才能到达最近的目标（目标指的是能到达结尾或者能到达最近的目标，其中最后一个目标能到达结尾）
  // 只有不行了，才会count++  如果距离为1，值为1，则1>0，所以重置   如果距离为1，值为0，则0<=0，不行了，count++,count表示，你等下得有一次跳count次数的数，才能救的了，否则救不活了  
  let count = 0
  // 注意，我是从nums.length-2开始的，所以最后一个元素的值根本无所谓，10000000还是-2222222222222都无所谓
  for (let i = nums.length - 2; i >= 0; i--) {
    console.log('在数组nums[', i, ']上的值是', nums[i], '当前count是', count)
    if (nums[i] <= count) {
      console.log('因为', nums[i], '小于等于', count, '所以')
      count++
      console.log('增加count，现在的count是', count)
    } else {
      console.log('因为', nums[i], '大于', count, '所以')
      count = 0
      console.log('重置count，现在的count是', count)
    }
  }
  console.log('结束遍历,最终的count是：', count)
  return count == 0
}

// 测试用例
console.log(canJump([4, 2, 1, 0, 4]))
```

## 跳跃游戏Ⅱ

```js
var jump = function (nums) {
  let n = nums.length
  let maxPos = 0 // maxPos表示，在下一步，你能到达的最远距离 i+nums[i]
  let end = 0 // end表示，在当前步，你能到达的最远距离,用maxPos记录
  let steps = 0

  for (let i = 0; i < n - 1; i++) {
    // 在无法到达的第一时间停止循环，避免了无谓的计算
    if (i <= maxPos) {
      console.log('maxPos为', maxPos)
      console.log('i为', i)
      console.log('nums[i]为', nums[i])
      console.log('i + nums[i]为', i + nums[i])
      maxPos = Math.max(maxPos, i + nums[i])
      console.log(`在索引${i}处，能跳到最远的位置是取maxPos和i+nums[i]两者的较大值${maxPos}`)
      if (i == end) {
        console.log('i为', i)
        console.log('更新前，end为', end)

        console.log('因为i == end，所以要更新end = maxPos')
        console.log('maxPos为', maxPos)

        end = maxPos
        steps++
        console.log(`在索引${i}处，增加步数，新步数为${steps}`)
      }
    }
  }

  return steps
}

jump([2, 3, 1, 1, 4])

```

## 划分字母区间

```js
var partitionLabels = function (s) {
  let map = new Map()
  let result = []
  let start = 0,
    end = 0
  for (let i = 0; i < s.length; i++) {
    map[s[i]] = i
  }
  for (let i = 0; i < s.length; i++) {
    end = Math.max(end, map[s[i]])
    if (i == end) {
      result.push(end - start + 1)
      start = i + 1
    }
  }
  return result
}
/*
步骤1: 创建一个哈希映射 map，来保存字符串 s 中每个字符最后一次出现的索引：

s: ababcbacadefegdehijhklij
map (字符:最后一次出现的索引): {'a': 8, 'b': 5, 'c': 7, 'd': 14, 'e': 15, 'f': 11, 'g': 13, 'h': 19, 'i': 22, 'j': 23, 'k': 20, 'l': 21}


步骤2: 创建两个变量 start 和 end 来记录每个分区的起始和结束位置，即初始值都是0。

步骤3: 遍历字符串 s，通过 map 得到当前字符最后一次出现的位置，用 end 记录当前准备切割的分区中，字符最后一次出现的最大索引。

例如：
- 当 i=0 (字符'a') 时，map 中 'a' 的最后一次出现位置是 8，因此 end 更新为 8。
- 当 i=1 (字符'b') 时，map 中 'b' 的最后一次出现位置是 5，但 end 仍然保持为 8，因为 8 是大于 5 的。

步骤4: 当遍历到的位置 i 到达当前分区的 end 时（也就是说我们已经到达了当前准备切割的分区中，字符最后一次出现的最大索引位置），这时候我们可以开始切割分区了。通过 end - start + 1 来计算当前分区的长度，并添加到结果集 result 中。然后更新 start 为下一个分区的起始位置，也就是当前结束位置 end 的下一个位置，即 i+1。

举个例子：
- 当 i/end =1, end（即1）计算的分区中字符最后一次出现的最大索引，然后将分区长度 end-start+1（即2）添加到结果数组，然后更新 start 为 i+1（即2）。

这个过程循环下去，直至整个字符串遍历完毕。这样我们就得到了每个符合条件的分区长度。

例如，对于 "ababcbacadefegdehijhklij" 这个字符串，最终会划分出三个分区：ababcbaca, defegde, hijhklij，他们的长度分别是：9,7,8。所以函数最后返回的结果是：9,7,8。
*/
```

# 动态规划

## 爬楼梯

```js
// 定义一个函数 climbStairs, 接收一个参数 n， 表示楼梯阶数
var climbStairs = function (n) {
  // 定义一个数组 dp, 用于存放每一阶对应的爬升方式数量
  let dp = []
  // 初始化dp数组的前三个值
  dp[0] = 0 // 无阶，爬楼梯方式为0
  dp[1] = 1 // 一阶，只能一次爬完，爬楼梯方式为1
  dp[2] = 2 // 二阶，可以一次爬两阶，或者一阶一阶爬，所以爬楼梯方式为2
  //从第 3 阶开始，计算每阶楼梯的爬升方式（dp[i] = dp[i - 1] + dp[i - 2]）
  // 每个阶梯的爬升方式都等于前两阶爬升方式之和
  // 使用 "for (let i = 3; i < n; i++)"，那么循环将在 i 等于 n-1 时停止，这意味着我们没有计算出爬到第 n 阶的所有可能的方法，只计算到了爬到第 n-1 阶的方法
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  // 返回n个楼梯的爬升方式
  return dp[n]
}
```

## 杨辉三角

## 打家劫舍

## 完全平方数

## 零钱兑换

## 单词拆分

## 最长递增子序列

## 乘积最大子数组

## 分割等和子集

## 最长有效括号

# 多维动态规划

## 不同路径

## 最小路径和

## 最长回文子串

## 最长公共子序列

## 编辑距离

# 技巧

## 只出现一次的数字

## 多数元素

## 颜色分类

## 下一个排列

## 寻找重复数
