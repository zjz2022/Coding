## 怎么比较

12比较，23比较，34比较

for循环，从0开始，每个nums[i]跟nums[i+1]比较

![image-20240414233558486](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/image-20240414233558486.png)

## 要比较几次

len-1次，每次都会把最大的放在最后面去

> 在冒泡排序中，需要len-1轮比较的原因是，在每一轮结束时，我们可以保证最大的元素已经排到了当前未排序部分的末尾。因此，经过第一轮排序后，最大的元素已经在最后的位置，第二轮排序后，次大的元素已经在倒数第二的位置，以此类推。
>
> 以4个元素的数组为例，[4, 3, 2, 1]：
>
> - 第一轮排序后，最大的元素4已经在最后一个位置：[3, 2, 1, 4]，剩余未排序的元素为3个。
> - 第二轮排序后，次大的元素3已经在倒数第二的位置：[2, 1, 3, 4]，剩余未排序的元素为2个。
> - 第三轮排序后，第三大的元素2已经在倒数第三的位置：[1, 2, 3, 4]，剩余未排序的元素为1个。
>
> 在第四轮的时候，其实只剩下一个元素未排序，但是由于这个元素已经是最小的，所以不需要再进行排序了。因此，总的需要的排序轮数就是元素个数减一。这就是为什么冒泡排序需要len-1轮比较的原因。

## 时间复杂度

冒泡排序的时间复杂度是O(n^2)。